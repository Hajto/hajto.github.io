---
layout: post
title: "What if we had only functions? How would your life look when there was no if statement.."
status: draft
type: post
comments: true
list: etut
---

Few days ago I've got a challenge from one of my teachers to write a simple C code without using loops, if and goto. It's a very nice opportunity to use recursion. Oh! And also, do you remember factorial definition from my last post? It was working but it's finally time to improve it so it won't mess your stack!

<!--more-->

First of all, the language I had to use C language. It was a pretty easy piece of code that had an instruction before and after checking loop condition. It looks more or less like this:

{% highlight elixir %}
void GoToLoop() {

pocz:
    X();
    if (n > 0) {
        Y();
        goto pocz;
     }
}
{% endhighlight %}

Let's just assume that X and Y are functions that does something that we don't really care at the moment. Unfortunately is very limited when it comes to function magic so we will have to declare some of them explicitly. We also can't use `If` statement, but that's really easy to workaround.

# Lazy AND

Have ever wondered what is the difference between `&` and `&&`? First one is called `binary and` and it performs bitwise operation. It will take two things, treat them as sequence of 1s and 0s and perform `AND` on each bit pair. Of course we can say that when it comes to boolean values we can treat it as `logical and`, because trues is represented as `11111111` and zero is `00000000`, but it has one really important property. It is eagerly evaluated. On the contrary, operator `&&` treats it's operands as boolean values and return a single boolean value. So are probably asking what's the real difference and why have I spent so much time explaining it to you? Because `&&` is lazy evaluated... It means that when it receives false as left param it won't bother to check the right one...

That's actually key to solving the puzzle. We can implement any `if statement` in such a way:

{% highlight c %}
(((condition) && iftrue()) || true) && ifelse();
{% endhighlight %}

Unfortunately C doesn't have anonymous functions and both `iftrue` and `ifelse` must return anything that has to be evaluated to true...

# First solution

Given these restrictions I came up with this code:

{% highlight c %}
void wrapper(){
    rec_petla();
    printf ("\n\tPetla Go To\t%10d %10d%10.4lf%10.4lf\n",i,n,x,y);
}

int rec_petla (){
    (X(), n > 0) && Y()  && rec_petla();
    return 1;
}
{% endhighlight %}
This particular code has to be working on upper scope variables (global in this context) which is less then ideal. The most annoying part though is that you actually have to fake return and make sure to return a value considered true.

That's why I decided whether Scala would behave a bit better.. And she indeed did..

{% highlight scala %}
def compute_no_if(xx: Double, y: Double, n: Int, ii: Int) : Any = {
  X()
  !((n <= 0) && {
    Y()
    true
  }) && {
    compute(new_x, new_y, new_n, new_i)
    true
  }
}
{% endhighlight %}

With a little bit of magic and sugar we can hide those binary operations and explicit true returns.

{% highlight scala %}
def my_if(condition : Boolean)( iftrue: () => Any)( ifnot: () => Any) = {
  !(condition && {
    iftrue
    true
  }) && {
    ifnot()
    true
  }
}
{% endhighlight  %}

{% highlight scala%}
def compute_c_if(xx: Double, y: Double, n: Int, ii: Int) : Any = {
  X()

  my_if(n <= 0) { () =>
    println(s"Wynik: $i $n $x $y")
  } { () =>
    Y()
  }
}
{% endhighlight %}

# Summing it up
After all of that. Is that code worth anything? Hell no! It's like introducing another layer of unnecessary complexity. We purposely tried to avoid using `if statement` and we ended up implementing our own...

And please NEVER use presented approach in production code.
